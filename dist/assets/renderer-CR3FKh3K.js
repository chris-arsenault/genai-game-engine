class t{constructor(t,s,h,i=0){this.name=t,this.width=s,this.height=h,this.zIndex=i,this.canvas=document.createElement("canvas"),this.canvas.width=s,this.canvas.height=h,this.ctx=this.canvas.getContext("2d"),this.dirty=!0,this.visible=!0,this.opacity=1}clear(){this.ctx.clearRect(0,0,this.width,this.height)}markDirty(){this.dirty=!0}markClean(){this.dirty=!1}setOpacity(t){this.opacity=Math.max(0,Math.min(1,t))}}class s{constructor(t=0,s=0,h=1280,i=720){this.x=t,this.y=s,this.width=h,this.height=i,this.zoom=1,this.followTarget=null,this.followSpeed=.1,this.shakeIntensity=0,this.shakeDecay=.9,this.shakeOffsetX=0,this.shakeOffsetY=0}follow(t,s=.1){this.followTarget=t,this.followSpeed=s}update(t,s){if(this.followTarget&&s){const t=s(this.followTarget);t&&(this.x+=(t.x-this.width/2-this.x)*this.followSpeed,this.y+=(t.y-this.height/2-this.y)*this.followSpeed)}this.shakeIntensity>.1?(this.shakeOffsetX=(Math.random()-.5)*this.shakeIntensity,this.shakeOffsetY=(Math.random()-.5)*this.shakeIntensity,this.shakeIntensity*=this.shakeDecay):(this.shakeIntensity=0,this.shakeOffsetX=0,this.shakeOffsetY=0)}shake(t=10){this.shakeIntensity=Math.max(this.shakeIntensity,t)}worldToScreen(t,s){return{x:(t-this.x)*this.zoom+this.shakeOffsetX,y:(s-this.y)*this.zoom+this.shakeOffsetY}}screenToWorld(t,s){return{x:(t-this.shakeOffsetX)/this.zoom+this.x,y:(s-this.shakeOffsetY)/this.zoom+this.y}}contains(t,s,h=0){return t>=this.x-h&&t<=this.x+this.width+h&&s>=this.y-h&&s<=this.y+this.height+h}}class h{constructor(t){this.canvas=t,this.ctx=t.getContext("2d"),this.width=t.width,this.height=t.height,this.camera=new s(0,0,this.width,this.height),this.layers=new Map,this._initLayers()}_initLayers(){[{name:"background",zIndex:0},{name:"tiles",zIndex:1},{name:"entities",zIndex:2},{name:"effects",zIndex:3},{name:"ui",zIndex:4}].forEach(s=>{const h=new t(s.name,this.width,this.height,s.zIndex);this.layers.set(s.name,h)})}getLayer(t){return this.layers.get(t)}render(t){this.ctx.clearRect(0,0,this.width,this.height);const s=Array.from(this.layers.values()).sort((t,s)=>t.zIndex-s.zIndex);for(const h of s)h.visible&&(this.ctx.globalAlpha=h.opacity,this.ctx.drawImage(h.canvas,0,0),this.ctx.globalAlpha=1)}clear(){this.ctx.clearRect(0,0,this.width,this.height);for(const t of this.layers.values())t.clear()}}export{h as R};
//# sourceMappingURL=renderer-CR3FKh3K.js.map
