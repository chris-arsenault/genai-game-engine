{"version":3,"file":"engine-Dl-Z51O5.js","sources":["../../src/engine/ecs/EntityManager.js","../../src/engine/ecs/ComponentRegistry.js","../../src/engine/ecs/SystemManager.js"],"sourcesContent":["/**\n * EntityManager - manages entity lifecycle (creation, destruction, queries).\n * Entities are lightweight unique IDs. The EntityManager tracks which entities exist\n * and maintains entity metadata (tags, active status).\n *\n * @class EntityManager\n */\nexport class EntityManager {\n  constructor() {\n    this.nextEntityId = 0;\n    this.entities = new Map(); // entityId -> Entity metadata\n    this.entitiesByTag = new Map(); // tag -> Set<entityId>\n    this.recycledIds = []; // Reuse IDs from destroyed entities\n  }\n\n  /**\n   * Creates a new entity and returns its unique ID.\n   * Reuses IDs from destroyed entities when possible to keep IDs compact.\n   *\n   * @param {string|null} tag - Optional tag for entity (e.g., 'player', 'enemy')\n   * @returns {number} Unique entity ID\n   */\n  createEntity(tag = null) {\n    let id;\n\n    // Reuse recycled ID if available, otherwise increment\n    if (this.recycledIds.length > 0) {\n      id = this.recycledIds.pop();\n    } else {\n      id = this.nextEntityId++;\n    }\n\n    // Store entity metadata\n    this.entities.set(id, {\n      id,\n      active: true,\n      tag,\n      componentTypes: new Set(), // Track which components this entity has\n    });\n\n    // Index by tag if provided\n    if (tag) {\n      if (!this.entitiesByTag.has(tag)) {\n        this.entitiesByTag.set(tag, new Set());\n      }\n      this.entitiesByTag.get(tag).add(id);\n    }\n\n    return id;\n  }\n\n  /**\n   * Destroys an entity and removes all its components.\n   * The entity ID is recycled for future use.\n   *\n   * @param {number} entityId - Entity ID to destroy\n   * @returns {boolean} True if entity was destroyed, false if not found\n   */\n  destroyEntity(entityId) {\n    const entity = this.entities.get(entityId);\n    if (!entity) {\n      return false;\n    }\n\n    // Remove from tag index\n    if (entity.tag) {\n      const tagSet = this.entitiesByTag.get(entity.tag);\n      if (tagSet) {\n        tagSet.delete(entityId);\n        if (tagSet.size === 0) {\n          this.entitiesByTag.delete(entity.tag);\n        }\n      }\n    }\n\n    // Remove entity\n    this.entities.delete(entityId);\n\n    // Recycle ID for future use\n    this.recycledIds.push(entityId);\n\n    return true;\n  }\n\n  /**\n   * Checks if an entity exists.\n   * @param {number} entityId - Entity ID to check\n   * @returns {boolean} True if entity exists\n   */\n  hasEntity(entityId) {\n    return this.entities.has(entityId);\n  }\n\n  /**\n   * Gets all active entity IDs.\n   * @returns {number[]} Array of active entity IDs\n   */\n  getAllEntities() {\n    const result = [];\n    for (const [id, entity] of this.entities) {\n      if (entity.active) {\n        result.push(id);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Gets entities by tag.\n   * @param {string} tag - Tag to query\n   * @returns {number[]} Array of entity IDs with matching tag\n   */\n  getEntitiesByTag(tag) {\n    const tagSet = this.entitiesByTag.get(tag);\n    if (!tagSet) {\n      return [];\n    }\n\n    // Filter by active status\n    const result = [];\n    for (const id of tagSet) {\n      const entity = this.entities.get(id);\n      if (entity && entity.active) {\n        result.push(id);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Sets entity tag.\n   * @param {number} entityId - Entity ID\n   * @param {string} tag - Tag name\n   */\n  setTag(entityId, tag) {\n    const entity = this.entities.get(entityId);\n    if (!entity) {\n      return;\n    }\n\n    // Remove from old tag index\n    if (entity.tag) {\n      const oldTagSet = this.entitiesByTag.get(entity.tag);\n      if (oldTagSet) {\n        oldTagSet.delete(entityId);\n        if (oldTagSet.size === 0) {\n          this.entitiesByTag.delete(entity.tag);\n        }\n      }\n    }\n\n    // Add to new tag index\n    entity.tag = tag;\n    if (!this.entitiesByTag.has(tag)) {\n      this.entitiesByTag.set(tag, new Set());\n    }\n    this.entitiesByTag.get(tag).add(entityId);\n  }\n\n  /**\n   * Gets entity tag.\n   * @param {number} entityId - Entity ID\n   * @returns {string|null} Tag name or null\n   */\n  getTag(entityId) {\n    const entity = this.entities.get(entityId);\n    return entity ? entity.tag : null;\n  }\n\n  /**\n   * Activates an entity (enables it for system updates).\n   * @param {number} entityId - Entity ID\n   */\n  activate(entityId) {\n    const entity = this.entities.get(entityId);\n    if (entity) {\n      entity.active = true;\n    }\n  }\n\n  /**\n   * Deactivates an entity (disables system updates but doesn't destroy).\n   * @param {number} entityId - Entity ID\n   */\n  deactivate(entityId) {\n    const entity = this.entities.get(entityId);\n    if (entity) {\n      entity.active = false;\n    }\n  }\n\n  /**\n   * Checks if entity is active.\n   * @param {number} entityId - Entity ID\n   * @returns {boolean} True if active\n   */\n  isActive(entityId) {\n    const entity = this.entities.get(entityId);\n    return entity ? entity.active : false;\n  }\n\n  /**\n   * Registers that an entity has a component (called by ComponentRegistry).\n   * @param {number} entityId - Entity ID\n   * @param {string} componentType - Component type\n   */\n  addComponentType(entityId, componentType) {\n    const entity = this.entities.get(entityId);\n    if (entity) {\n      entity.componentTypes.add(componentType);\n    }\n  }\n\n  /**\n   * Unregisters that an entity has a component (called by ComponentRegistry).\n   * @param {number} entityId - Entity ID\n   * @param {string} componentType - Component type\n   */\n  removeComponentType(entityId, componentType) {\n    const entity = this.entities.get(entityId);\n    if (entity) {\n      entity.componentTypes.delete(componentType);\n    }\n  }\n\n  /**\n   * Gets component types for an entity.\n   * @param {number} entityId - Entity ID\n   * @returns {Set<string>} Set of component type names\n   */\n  getComponentTypes(entityId) {\n    const entity = this.entities.get(entityId);\n    return entity ? entity.componentTypes : new Set();\n  }\n\n  /**\n   * Gets total entity count (including inactive).\n   * @returns {number} Total entity count\n   */\n  getEntityCount() {\n    return this.entities.size;\n  }\n\n  /**\n   * Gets active entity count.\n   * @returns {number} Active entity count\n   */\n  getActiveEntityCount() {\n    let count = 0;\n    for (const entity of this.entities.values()) {\n      if (entity.active) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Clears all entities (used for level transitions).\n   */\n  clear() {\n    this.entities.clear();\n    this.entitiesByTag.clear();\n    this.recycledIds = [];\n    this.nextEntityId = 0;\n  }\n}\n","/**\n * ComponentRegistry - stores component data and provides efficient queries.\n * Components are stored in a Map<ComponentType, Map<EntityID, ComponentData>> structure\n * for cache-friendly data layout and O(1) component access.\n *\n * Query optimization: Uses smallest-set optimization for O(n) queries where n = smallest\n * component set size.\n *\n * @class ComponentRegistry\n */\nexport class ComponentRegistry {\n  /**\n   * Creates a new component registry.\n   * @param {EntityManager} entityManager - Entity manager for lifecycle coordination\n   */\n  constructor(entityManager) {\n    this.entityManager = entityManager;\n    this.components = new Map(); // componentType -> Map<entityId, componentData>\n    this.queryCache = new Map(); // Cache for query results (cleared on component changes)\n  }\n\n  /**\n   * Adds a component to an entity.\n   * @param {number} entityId - Entity ID\n   * @param {Component} component - Component instance\n   * @throws {Error} If entity doesn't exist\n   */\n  addComponent(entityId, component) {\n    if (!this.entityManager.hasEntity(entityId)) {\n      throw new Error(`Cannot add component to non-existent entity ${entityId}`);\n    }\n\n    const componentType = component.type;\n\n    // Create component type storage if needed\n    if (!this.components.has(componentType)) {\n      this.components.set(componentType, new Map());\n    }\n\n    // Store component data\n    this.components.get(componentType).set(entityId, component);\n\n    // Update entity's component type list\n    this.entityManager.addComponentType(entityId, componentType);\n\n    // Invalidate query cache\n    this.queryCache.clear();\n  }\n\n  /**\n   * Removes a component from an entity.\n   * @param {number} entityId - Entity ID\n   * @param {string} componentType - Component type to remove\n   * @returns {boolean} True if component was removed, false if not found\n   */\n  removeComponent(entityId, componentType) {\n    const typeMap = this.components.get(componentType);\n    if (!typeMap) {\n      return false;\n    }\n\n    const removed = typeMap.delete(entityId);\n    if (removed) {\n      // Update entity's component type list\n      this.entityManager.removeComponentType(entityId, componentType);\n\n      // Invalidate query cache\n      this.queryCache.clear();\n    }\n\n    return removed;\n  }\n\n  /**\n   * Gets a component from an entity.\n   * @param {number} entityId - Entity ID\n   * @param {string} componentType - Component type\n   * @returns {Component|undefined} Component data or undefined if not found\n   */\n  getComponent(entityId, componentType) {\n    const typeMap = this.components.get(componentType);\n    return typeMap ? typeMap.get(entityId) : undefined;\n  }\n\n  /**\n   * Checks if entity has a component.\n   * @param {number} entityId - Entity ID\n   * @param {string} componentType - Component type\n   * @returns {boolean} True if entity has component\n   */\n  hasComponent(entityId, componentType) {\n    const typeMap = this.components.get(componentType);\n    return typeMap ? typeMap.has(entityId) : false;\n  }\n\n  /**\n   * Gets all components of a specific type.\n   * @param {string} componentType - Component type\n   * @returns {Map<number, Component>} Map of entityId -> component\n   */\n  getComponentsOfType(componentType) {\n    return this.components.get(componentType) || new Map();\n  }\n\n  /**\n   * Queries entities that have ALL specified components.\n   * Uses smallest-set optimization for performance: O(n) where n = smallest component set.\n   *\n   * @param {...string} componentTypes - Component types to query\n   * @returns {number[]} Array of entity IDs matching query\n   *\n   * @example\n   * // Get all entities with Position and Velocity\n   * const movingEntities = registry.queryEntities('Position', 'Velocity');\n   */\n  queryEntities(...componentTypes) {\n    if (componentTypes.length === 0) {\n      return this.entityManager.getAllEntities();\n    }\n\n    // Check cache\n    const cacheKey = componentTypes.sort().join(',');\n    if (this.queryCache.has(cacheKey)) {\n      return this.queryCache.get(cacheKey);\n    }\n\n    // Find smallest component set for optimization\n    let smallestType = componentTypes[0];\n    let smallestSize = this.components.get(componentTypes[0])?.size || 0;\n\n    for (let i = 1; i < componentTypes.length; i++) {\n      const currentSize = this.components.get(componentTypes[i])?.size || 0;\n      if (currentSize < smallestSize) {\n        smallestType = componentTypes[i];\n        smallestSize = currentSize;\n      }\n    }\n\n    // If smallest set is empty, no entities match\n    if (smallestSize === 0) {\n      this.queryCache.set(cacheKey, []);\n      return [];\n    }\n\n    // Iterate through smallest set and check if entity has all other components\n    const smallestSet = this.components.get(smallestType);\n    const result = [];\n\n    for (const entityId of smallestSet.keys()) {\n      // Check if entity is active\n      if (!this.entityManager.isActive(entityId)) {\n        continue;\n      }\n\n      // Check if entity has all required components\n      let hasAll = true;\n      for (const type of componentTypes) {\n        if (type === smallestType) {\n          continue;\n        }\n        if (!this.hasComponent(entityId, type)) {\n          hasAll = false;\n          break;\n        }\n      }\n\n      if (hasAll) {\n        result.push(entityId);\n      }\n    }\n\n    // Cache result\n    this.queryCache.set(cacheKey, result);\n    return result;\n  }\n\n  /**\n   * Queries entities that have ANY of the specified components.\n   * @param {...string} componentTypes - Component types to query\n   * @returns {number[]} Array of entity IDs matching query\n   */\n  queryEntitiesAny(...componentTypes) {\n    if (componentTypes.length === 0) {\n      return [];\n    }\n\n    const resultSet = new Set();\n\n    for (const type of componentTypes) {\n      const typeMap = this.components.get(type);\n      if (typeMap) {\n        for (const entityId of typeMap.keys()) {\n          if (this.entityManager.isActive(entityId)) {\n            resultSet.add(entityId);\n          }\n        }\n      }\n    }\n\n    return Array.from(resultSet);\n  }\n\n  /**\n   * Removes all components from an entity.\n   * Called by EntityManager.destroyEntity.\n   *\n   * @param {number} entityId - Entity ID\n   */\n  removeAllComponents(entityId) {\n    const componentTypes = this.entityManager.getComponentTypes(entityId);\n\n    for (const type of componentTypes) {\n      this.removeComponent(entityId, type);\n    }\n  }\n\n  /**\n   * Gets total component count across all entities.\n   * @returns {number} Total component count\n   */\n  getComponentCount() {\n    let count = 0;\n    for (const typeMap of this.components.values()) {\n      count += typeMap.size;\n    }\n    return count;\n  }\n\n  /**\n   * Gets component count for a specific type.\n   * @param {string} componentType - Component type\n   * @returns {number} Component count\n   */\n  getComponentCountOfType(componentType) {\n    const typeMap = this.components.get(componentType);\n    return typeMap ? typeMap.size : 0;\n  }\n\n  /**\n   * Clears all components (used for level transitions).\n   */\n  clear() {\n    this.components.clear();\n    this.queryCache.clear();\n  }\n\n  /**\n   * Gets all registered component types.\n   * @returns {string[]} Array of component type names\n   */\n  getComponentTypes() {\n    return Array.from(this.components.keys());\n  }\n}\n","/**\n * SystemManager - orchestrates system lifecycle and update loop.\n * Systems are updated in priority order each frame.\n * Priority values: 0 = highest (runs first), 100 = lowest (runs last).\n *\n * @class SystemManager\n */\nexport class SystemManager {\n  /**\n   * Creates a new system manager.\n   * @param {EntityManager} entityManager - Entity manager instance\n   * @param {ComponentRegistry} componentRegistry - Component registry instance\n   * @param {EventBus} eventBus - Event bus instance\n   */\n  constructor(entityManager, componentRegistry, eventBus) {\n    this.entityManager = entityManager;\n    this.componentRegistry = componentRegistry;\n    this.eventBus = eventBus;\n    this.systems = [];\n    this.systemsByName = new Map();\n  }\n\n  /**\n   * Registers a system and initializes it.\n   * Systems are automatically sorted by priority after registration.\n   *\n   * @param {System} system - System instance to register\n   * @param {string} name - System name for lookup (optional)\n   * @throws {Error} If system with same name already registered\n   */\n  registerSystem(system, name = null) {\n    // Check for duplicate name\n    if (name && this.systemsByName.has(name)) {\n      throw new Error(`System with name \"${name}\" already registered`);\n    }\n\n    // Inject dependencies\n    system.componentRegistry = this.componentRegistry;\n    system.eventBus = this.eventBus;\n\n    // Add to systems list\n    this.systems.push(system);\n\n    // Store by name if provided\n    if (name) {\n      this.systemsByName.set(name, system);\n    }\n\n    // Sort by priority (lower priority = runs earlier)\n    this.systems.sort((a, b) => a.priority - b.priority);\n\n    // Initialize system\n    system.init();\n  }\n\n  /**\n   * Unregisters a system and cleans it up.\n   * @param {string} name - System name\n   * @returns {boolean} True if system was unregistered\n   */\n  unregisterSystem(name) {\n    const system = this.systemsByName.get(name);\n    if (!system) {\n      return false;\n    }\n\n    // Cleanup system\n    system.cleanup();\n\n    // Remove from systems list\n    const index = this.systems.indexOf(system);\n    if (index !== -1) {\n      this.systems.splice(index, 1);\n    }\n\n    // Remove from name map\n    this.systemsByName.delete(name);\n\n    return true;\n  }\n\n  /**\n   * Gets a system by name.\n   * @param {string} name - System name\n   * @returns {System|undefined} System instance or undefined\n   */\n  getSystem(name) {\n    return this.systemsByName.get(name);\n  }\n\n  /**\n   * Updates all enabled systems.\n   * This is called once per frame by the game loop.\n   *\n   * Performance target: <6ms for all systems combined.\n   *\n   * @param {number} deltaTime - Time elapsed since last frame in seconds\n   */\n  update(deltaTime) {\n    for (let i = 0; i < this.systems.length; i++) {\n      const system = this.systems[i];\n\n      // Skip disabled systems\n      if (!system.enabled) {\n        continue;\n      }\n\n      // Query entities that match system's required components\n      const entities = this.componentRegistry.queryEntities(...system.requiredComponents);\n\n      // Update system with matching entities\n      system.update(deltaTime, entities);\n    }\n  }\n\n  /**\n   * Initializes all systems.\n   * Call this once on engine startup.\n   */\n  init() {\n    for (const system of this.systems) {\n      system.init();\n    }\n  }\n\n  /**\n   * Cleans up all systems.\n   * Call this on engine shutdown.\n   */\n  cleanup() {\n    for (const system of this.systems) {\n      system.cleanup();\n    }\n  }\n\n  /**\n   * Enables a system.\n   * @param {string} name - System name\n   * @returns {boolean} True if system was enabled\n   */\n  enableSystem(name) {\n    const system = this.systemsByName.get(name);\n    if (system) {\n      system.enable();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Disables a system.\n   * @param {string} name - System name\n   * @returns {boolean} True if system was disabled\n   */\n  disableSystem(name) {\n    const system = this.systemsByName.get(name);\n    if (system) {\n      system.disable();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Gets all registered system names.\n   * @returns {string[]} Array of system names\n   */\n  getSystemNames() {\n    return Array.from(this.systemsByName.keys());\n  }\n\n  /**\n   * Gets count of registered systems.\n   * @returns {number} System count\n   */\n  getSystemCount() {\n    return this.systems.length;\n  }\n\n  /**\n   * Gets count of enabled systems.\n   * @returns {number} Enabled system count\n   */\n  getEnabledSystemCount() {\n    let count = 0;\n    for (const system of this.systems) {\n      if (system.enabled) {\n        count++;\n      }\n    }\n    return count;\n  }\n}\n"],"names":["EntityManager","constructor","this","nextEntityId","entities","Map","entitiesByTag","recycledIds","createEntity","tag","id","length","pop","set","active","componentTypes","Set","has","get","add","destroyEntity","entityId","entity","tagSet","delete","size","push","hasEntity","getAllEntities","result","getEntitiesByTag","setTag","oldTagSet","getTag","activate","deactivate","isActive","addComponentType","componentType","removeComponentType","getComponentTypes","getEntityCount","getActiveEntityCount","count","values","clear","ComponentRegistry","entityManager","components","queryCache","addComponent","component","Error","type","removeComponent","typeMap","removed","getComponent","hasComponent","getComponentsOfType","queryEntities","cacheKey","sort","join","smallestType","smallestSize","i","currentSize","smallestSet","keys","hasAll","queryEntitiesAny","resultSet","Array","from","removeAllComponents","getComponentCount","getComponentCountOfType","SystemManager","componentRegistry","eventBus","systems","systemsByName","registerSystem","system","name","a","b","priority","init","unregisterSystem","cleanup","index","indexOf","splice","getSystem","update","deltaTime","enabled","requiredComponents","enableSystem","enable","disableSystem","disable","getSystemNames","getSystemCount","getEnabledSystemCount"],"mappings":"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"}