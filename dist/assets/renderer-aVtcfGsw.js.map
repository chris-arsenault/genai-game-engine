{"version":3,"file":"renderer-aVtcfGsw.js","sources":["../../src/engine/renderer/Camera.js","../../src/engine/renderer/Renderer.js"],"sourcesContent":["/**\n * Camera - viewport management and coordinate transformation.\n *\n * Handles:\n * - World-to-screen and screen-to-world coordinate conversion\n * - Smooth camera following (lerp-based)\n * - Camera shake effects\n * - Zoom support\n * - Viewport culling tests\n *\n * @class Camera\n */\nexport class Camera {\n  /**\n   * Creates a new camera.\n   * @param {number} x - Initial world X position (top-left of viewport)\n   * @param {number} y - Initial world Y position (top-left of viewport)\n   * @param {number} width - Viewport width in pixels\n   * @param {number} height - Viewport height in pixels\n   */\n  constructor(x = 0, y = 0, width = 1280, height = 720) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.zoom = 1.0;\n\n    // Following behavior\n    this.followTarget = null;\n    this.followSpeed = 0.1; // 0.0 = instant, 1.0 = no follow\n    this.followOffsetX = 0;\n    this.followOffsetY = 0;\n\n    // Screen shake\n    this.shakeIntensity = 0;\n    this.shakeDecay = 0.9;\n    this.shakeOffsetX = 0;\n    this.shakeOffsetY = 0;\n  }\n\n  /**\n   * Sets the camera to follow an entity.\n   * @param {number|null} entityId - Entity ID to follow, or null to stop following\n   * @param {number} speed - Follow speed (0.0 to 1.0, lower = smoother)\n   * @param {number} offsetX - X offset from entity center\n   * @param {number} offsetY - Y offset from entity center\n   */\n  follow(entityId, speed = 0.1, offsetX = 0, offsetY = 0) {\n    this.followTarget = entityId;\n    this.followSpeed = Math.max(0, Math.min(1, speed));\n    this.followOffsetX = offsetX;\n    this.followOffsetY = offsetY;\n  }\n\n  /**\n   * Stops following the current target.\n   */\n  stopFollowing() {\n    this.followTarget = null;\n  }\n\n  /**\n   * Updates camera position (following and shake).\n   * @param {number} deltaTime - Time since last frame in seconds\n   * @param {Function} getPosition - Function(entityId) => {x, y} to get entity position\n   */\n  update(deltaTime, getPosition) {\n    // Update following\n    if (this.followTarget && getPosition) {\n      const pos = getPosition(this.followTarget);\n      if (pos) {\n        // Target the center of viewport\n        const targetX = pos.x - this.width / (2 * this.zoom) + this.followOffsetX;\n        const targetY = pos.y - this.height / (2 * this.zoom) + this.followOffsetY;\n\n        // Smooth lerp\n        const lerpAmount = 1 - Math.pow(1 - this.followSpeed, deltaTime * 60);\n        this.x += (targetX - this.x) * lerpAmount;\n        this.y += (targetY - this.y) * lerpAmount;\n      }\n    }\n\n    // Update shake\n    if (this.shakeIntensity > 0.1) {\n      this.shakeOffsetX = (Math.random() - 0.5) * this.shakeIntensity;\n      this.shakeOffsetY = (Math.random() - 0.5) * this.shakeIntensity;\n      this.shakeIntensity *= this.shakeDecay;\n    } else {\n      this.shakeIntensity = 0;\n      this.shakeOffsetX = 0;\n      this.shakeOffsetY = 0;\n    }\n  }\n\n  /**\n   * Triggers camera shake.\n   * @param {number} intensity - Shake intensity in pixels\n   * @param {number} decay - Decay rate per frame (0.0 to 1.0, default 0.9)\n   */\n  shake(intensity = 10, decay = 0.9) {\n    this.shakeIntensity = Math.max(this.shakeIntensity, intensity);\n    this.shakeDecay = decay;\n  }\n\n  /**\n   * Converts world coordinates to screen coordinates.\n   * @param {number} worldX - World X coordinate\n   * @param {number} worldY - World Y coordinate\n   * @returns {{x: number, y: number}} Screen coordinates\n   */\n  worldToScreen(worldX, worldY) {\n    return {\n      x: (worldX - this.x) * this.zoom + this.shakeOffsetX,\n      y: (worldY - this.y) * this.zoom + this.shakeOffsetY,\n    };\n  }\n\n  /**\n   * Converts screen coordinates to world coordinates.\n   * @param {number} screenX - Screen X coordinate\n   * @param {number} screenY - Screen Y coordinate\n   * @returns {{x: number, y: number}} World coordinates\n   */\n  screenToWorld(screenX, screenY) {\n    return {\n      x: (screenX - this.shakeOffsetX) / this.zoom + this.x,\n      y: (screenY - this.shakeOffsetY) / this.zoom + this.y,\n    };\n  }\n\n  /**\n   * Checks if a point is visible in the viewport.\n   * @param {number} x - World X coordinate\n   * @param {number} y - World Y coordinate\n   * @param {number} margin - Extra margin in pixels (default 0)\n   * @returns {boolean} True if point is visible\n   */\n  contains(x, y, margin = 0) {\n    return (\n      x >= this.x - margin &&\n      x <= this.x + this.width / this.zoom + margin &&\n      y >= this.y - margin &&\n      y <= this.y + this.height / this.zoom + margin\n    );\n  }\n\n  /**\n   * Checks if a rectangle is visible in the viewport.\n   * @param {number} x - World X coordinate (top-left)\n   * @param {number} y - World Y coordinate (top-left)\n   * @param {number} width - Rectangle width\n   * @param {number} height - Rectangle height\n   * @returns {boolean} True if rectangle is visible (or partially visible)\n   */\n  containsRect(x, y, width, height) {\n    const camRight = this.x + this.width / this.zoom;\n    const camBottom = this.y + this.height / this.zoom;\n    const rectRight = x + width;\n    const rectBottom = y + height;\n\n    return !(\n      rectRight < this.x ||\n      x > camRight ||\n      rectBottom < this.y ||\n      y > camBottom\n    );\n  }\n\n  /**\n   * Sets camera position directly.\n   * @param {number} x - World X coordinate\n   * @param {number} y - World Y coordinate\n   */\n  setPosition(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Moves camera by offset.\n   * @param {number} dx - X offset\n   * @param {number} dy - Y offset\n   */\n  move(dx, dy) {\n    this.x += dx;\n    this.y += dy;\n  }\n\n  /**\n   * Sets camera zoom.\n   * @param {number} zoom - Zoom level (1.0 = normal, >1.0 = zoomed in, <1.0 = zoomed out)\n   */\n  setZoom(zoom) {\n    this.zoom = Math.max(0.1, Math.min(10, zoom));\n  }\n\n  /**\n   * Gets the camera bounds in world coordinates.\n   * @returns {{x: number, y: number, width: number, height: number}} Camera bounds\n   */\n  getBounds() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width / this.zoom,\n      height: this.height / this.zoom,\n    };\n  }\n\n  /**\n   * Gets the camera center in world coordinates.\n   * @returns {{x: number, y: number}} Camera center\n   */\n  getCenter() {\n    return {\n      x: this.x + this.width / (2 * this.zoom),\n      y: this.y + this.height / (2 * this.zoom),\n    };\n  }\n}\n","/**\n * Renderer - main rendering coordinator with performance tracking.\n *\n * Manages canvas, camera, and delegates layer rendering to LayeredRenderer.\n * Tracks frame timing to ensure <8ms rendering budget.\n *\n * Performance target: <8ms per frame for rendering.\n *\n * @class Renderer\n */\nimport { Camera } from './Camera.js';\n\nexport class Renderer {\n  /**\n   * Creates a new renderer.\n   * @param {HTMLCanvasElement} canvas - Main rendering canvas\n   */\n  constructor(canvas) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d', { alpha: false });\n    this.width = canvas.width;\n    this.height = canvas.height;\n\n    // Camera for world-to-screen transformation\n    this.camera = new Camera(0, 0, this.width, this.height);\n\n    // Performance tracking\n    this.frameTime = 0;\n    this.renderTime = 0;\n    this.lastFrameStart = 0;\n\n    // Rendering options\n    this.clearColor = '#000000';\n    this.imageSmoothing = false; // Pixel art friendly\n\n    // Configure context for pixel art\n    this.ctx.imageSmoothingEnabled = this.imageSmoothing;\n\n    // Handle canvas resize\n    this._setupResizeObserver();\n  }\n\n  /**\n   * Sets up resize observer to handle canvas size changes.\n   * @private\n   */\n  _setupResizeObserver() {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          if (entry.target === this.canvas) {\n            this.handleResize();\n          }\n        }\n      });\n      this.resizeObserver.observe(this.canvas);\n    }\n  }\n\n  /**\n   * Handles canvas resize events.\n   * Updates internal dimensions and camera viewport.\n   */\n  handleResize() {\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.camera.width = this.width;\n    this.camera.height = this.height;\n  }\n\n  /**\n   * Clears the main canvas.\n   */\n  clear() {\n    this.ctx.fillStyle = this.clearColor;\n    this.ctx.fillRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Begins a new frame.\n   * Call this at the start of each render cycle.\n   * @returns {number} Frame start timestamp\n   */\n  beginFrame() {\n    this.lastFrameStart = performance.now();\n    return this.lastFrameStart;\n  }\n\n  /**\n   * Ends the current frame and updates timing metrics.\n   * Call this at the end of each render cycle.\n   */\n  endFrame() {\n    const frameEnd = performance.now();\n    this.renderTime = frameEnd - this.lastFrameStart;\n    this.frameTime = this.renderTime;\n  }\n\n  /**\n   * Gets the camera instance.\n   * @returns {Camera} Camera instance\n   */\n  getCamera() {\n    return this.camera;\n  }\n\n  /**\n   * Sets the clear color.\n   * @param {string} color - CSS color string (e.g., '#000000')\n   */\n  setClearColor(color) {\n    this.clearColor = color;\n  }\n\n  /**\n   * Sets image smoothing (for pixel art vs smooth sprites).\n   * @param {boolean} enabled - Whether to enable smoothing\n   */\n  setImageSmoothing(enabled) {\n    this.imageSmoothing = enabled;\n    this.ctx.imageSmoothingEnabled = enabled;\n  }\n\n  /**\n   * Gets current frame render time in milliseconds.\n   * @returns {number} Render time in ms\n   */\n  getRenderTime() {\n    return this.renderTime;\n  }\n\n  /**\n   * Converts world coordinates to screen coordinates.\n   * @param {number} worldX - World X coordinate\n   * @param {number} worldY - World Y coordinate\n   * @returns {{x: number, y: number}} Screen coordinates\n   */\n  worldToScreen(worldX, worldY) {\n    return this.camera.worldToScreen(worldX, worldY);\n  }\n\n  /**\n   * Converts screen coordinates to world coordinates.\n   * @param {number} screenX - Screen X coordinate\n   * @param {number} screenY - Screen Y coordinate\n   * @returns {{x: number, y: number}} World coordinates\n   */\n  screenToWorld(screenX, screenY) {\n    return this.camera.screenToWorld(screenX, screenY);\n  }\n\n  /**\n   * Checks if a world position is visible in the viewport.\n   * @param {number} x - World X coordinate\n   * @param {number} y - World Y coordinate\n   * @param {number} margin - Extra margin in pixels\n   * @returns {boolean} True if visible\n   */\n  isVisible(x, y, margin = 0) {\n    return this.camera.contains(x, y, margin);\n  }\n\n  /**\n   * Checks if a rectangle is visible in the viewport.\n   * @param {number} x - World X coordinate (top-left)\n   * @param {number} y - World Y coordinate (top-left)\n   * @param {number} width - Rectangle width\n   * @param {number} height - Rectangle height\n   * @returns {boolean} True if visible (or partially visible)\n   */\n  isRectVisible(x, y, width, height) {\n    const cam = this.camera;\n    return !(\n      x + width < cam.x ||\n      x > cam.x + cam.width ||\n      y + height < cam.y ||\n      y > cam.y + cam.height\n    );\n  }\n\n  /**\n   * Updates camera (call once per frame).\n   * @param {number} deltaTime - Time since last frame in seconds\n   * @param {Function} getPosition - Function to get entity position (for follow target)\n   */\n  updateCamera(deltaTime, getPosition) {\n    this.camera.update(deltaTime, getPosition);\n  }\n\n  /**\n   * Cleanup resources.\n   */\n  cleanup() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  }\n}\n"],"names":["Camera","constructor","x","y","width","height","this","zoom","followTarget","followSpeed","followOffsetX","followOffsetY","shakeIntensity","shakeDecay","shakeOffsetX","shakeOffsetY","follow","entityId","speed","offsetX","offsetY","Math","max","min","stopFollowing","update","deltaTime","getPosition","pos","targetX","targetY","lerpAmount","pow","random","shake","intensity","decay","worldToScreen","worldX","worldY","screenToWorld","screenX","screenY","contains","margin","containsRect","camRight","camBottom","rectBottom","setPosition","move","dx","dy","setZoom","getBounds","getCenter","Renderer","canvas","ctx","getContext","alpha","camera","frameTime","renderTime","lastFrameStart","clearColor","imageSmoothing","imageSmoothingEnabled","_setupResizeObserver","ResizeObserver","resizeObserver","entries","entry","target","handleResize","observe","clear","fillStyle","fillRect","beginFrame","performance","now","endFrame","frameEnd","getCamera","setClearColor","color","setImageSmoothing","enabled","getRenderTime","isVisible","isRectVisible","cam","updateCamera","cleanup","disconnect"],"mappings":"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"}