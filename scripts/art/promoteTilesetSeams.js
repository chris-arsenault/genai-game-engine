#!/usr/bin/env node
/**
 * Promote tileset seam warnings into authored metadata.
 *
 * Consumes a tileset analysis report generated by `analyzeTilesetSeams.js`
 * and emits a metadata manifest capturing door seam annotations that can be
 * consumed by downstream tooling (tileset previews, corridor painters, etc.).
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

function parseArgs(argv) {
  const options = {
    analysis: null,
    out: null,
    help: false,
  };

  for (const arg of argv) {
    if (arg === '--help' || arg === '-h') {
      options.help = true;
      continue;
    }

    if (arg.startsWith('--analysis=')) {
      options.analysis = arg.slice('--analysis='.length);
      continue;
    }

    if (arg.startsWith('--out=')) {
      options.out = arg.slice('--out='.length);
      continue;
    }
  }

  return options;
}

function printUsage() {
  console.log(`Usage: node scripts/art/promoteTilesetSeams.js --analysis=<path> [--out=<path>]

Options:
  --analysis=<path>   Tileset analysis JSON generated by analyzeTilesetSeams.js (required)
  --out=<path>        Output metadata file (defaults to assets/manifests/tilesets/<tilesetId>-metadata.json)
  --help              Show this message
`);
}

function normalizeEdgeKey(edge) {
  switch (edge) {
    case 'top':
      return 'north';
    case 'bottom':
      return 'south';
    case 'left':
      return 'west';
    case 'right':
      return 'east';
    default:
      return edge;
  }
}

function determineOrientationFromEdge(edge) {
  if (edge === 'north' || edge === 'south' || edge === 'top' || edge === 'bottom') {
    return 'vertical';
  }
  if (edge === 'east' || edge === 'west' || edge === 'left' || edge === 'right') {
    return 'horizontal';
  }
  return 'unknown';
}

function collectEdgesByClassification(tile) {
  const edges = {
    open: [],
    blocking: [],
    mixed: [],
  };

  for (const [edge, stats] of Object.entries(tile.edges)) {
    const normalizedEdge = normalizeEdgeKey(edge);
    if (stats.classification === 'open') {
      edges.open.push(normalizedEdge);
    } else if (stats.classification === 'blocking') {
      edges.blocking.push(normalizedEdge);
    } else {
      edges.mixed.push(normalizedEdge);
    }
  }

  return edges;
}

async function readJson(filePath) {
  const raw = await fs.readFile(filePath, 'utf8');
  return JSON.parse(raw);
}

async function writeJson(filePath, data) {
  const serialized = `${JSON.stringify(data, null, 2)}\n`;
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, serialized, 'utf8');
}

async function promoteTilesetSeams({ analysisPath, outputPath }) {
  const analysis = await readJson(analysisPath);

  if (!analysis.tilesetId) {
    throw new Error('[promoteTilesetSeams] Analysis JSON is missing "tilesetId".');
  }

  if (!Array.isArray(analysis.tiles) || analysis.tiles.length === 0) {
    throw new Error('[promoteTilesetSeams] Analysis JSON is missing per-tile metrics.');
  }

  if (!Array.isArray(analysis.warnings) || analysis.warnings.length === 0) {
    throw new Error('[promoteTilesetSeams] No warnings found to promote.');
  }

  const tilesByIndex = new Map(analysis.tiles.map((tile) => [tile.index, tile]));

  const seamAnnotations = [];
  for (const warning of analysis.warnings) {
    const tile = tilesByIndex.get(warning.tileIndex);
    if (!tile) {
      // eslint-disable-next-line no-console
      console.warn(
        `[promoteTilesetSeams] Skipping warning for tileIndex ${warning.tileIndex}; tile metrics not found.`
      );
      continue;
    }

    const edges = collectEdgesByClassification(tile);
    if (edges.open.length === 0) {
      // eslint-disable-next-line no-console
      console.warn(
        `[promoteTilesetSeams] Warning for tileIndex ${warning.tileIndex} has no open edges; skipping.`
      );
      continue;
    }

    const openEdge = edges.open[0];
    const orientation = determineOrientationFromEdge(openEdge);
    const tags = ['doorway', orientation];

    seamAnnotations.push({
      tileIndex: tile.index,
      row: tile.row,
      column: tile.column,
      openEdge,
      blockingEdges: edges.blocking,
      mixedEdges: edges.mixed,
      tileClassification: tile.classification,
      collision: tile.collisionSuggestion,
      solidCoverage: tile.solidCoverage,
      warningType: warning.type,
      warningMessage: warning.message,
      orientation,
      tags,
    });
  }

  seamAnnotations.sort((a, b) => a.tileIndex - b.tileIndex);

  const metadata = {
    tilesetId: analysis.tilesetId,
    sourceImage: analysis.sourceImage ?? null,
    tileSize: analysis.tileSize,
    promotedAt: analysis.generatedAt ?? new Date().toISOString(),
    sourceAnalysis: path.relative(process.cwd(), analysisPath),
    totals: {
      warnings: analysis.warnings.length,
      promoted: seamAnnotations.length,
    },
    seamAnnotations,
  };

  await writeJson(outputPath, metadata);
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  if (args.help || !args.analysis) {
    printUsage();
    process.exit(args.help ? 0 : 1);
  }

  const analysisPath = path.resolve(process.cwd(), args.analysis);
  let outputPath = args.out
    ? path.resolve(process.cwd(), args.out)
    : path.resolve(
        process.cwd(),
        'assets',
        'manifests',
        'tilesets',
        `${path.basename(analysisPath).replace('-analysis', '').replace(/\\.json$/, '')}-metadata.json`
      );

  const analysis = await readJson(analysisPath);

  if (!args.out) {
    const tilesetId = analysis.tilesetId ?? path.basename(analysisPath, '.json');
    outputPath = path.resolve(
      process.cwd(),
      'assets',
      'manifests',
      'tilesets',
      `${tilesetId}-metadata.json`
    );
  }

  await promoteTilesetSeams({ analysisPath, outputPath });
}

main().catch((error) => {
  // eslint-disable-next-line no-console
  console.error(error instanceof Error ? error.message : error);
  process.exit(1);
});

export { promoteTilesetSeams };
